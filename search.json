[{"title":"Hello World","url":"/2025/06/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"page背包问题(动态规划)","url":"/2025/07/10/page%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"背包问题 （动态规划）\n(一) 背包问题学习大纲\n基础概念 a. [什么是背包问题](#什么是背包问题 ?) b. 背包问题的基本形式\n\n背包问题的主要类型 a. 0-1背包问题：每个物品要么选要么不选（不能分割） b. 完全背包问题：每个物品可以选无限次 c. 多重背包问题：每个物品有数量限制 d. 混合背包问题 e. 二维费用背包问题 f. 分组背包问题：物品分组，每组只能选一个 g.背包问题求方案数 h.求背包问题的方案 i.有依赖的背包问题\n\n解法技术\n\n优化技巧\n\n扩展应用\n\n\n(二) 正文\n什么是背包问题 ？背包问题(Knapsack Problem)是组合优化中的一个经典问题,核心思想是——在有限的资源约束下，如何选择物品的组合，来实现目标限通常描述如下：给定一个容量为 W 的背包, 以及 n个物品, 每个物品 i 有:\n\n一个重量 wi （weight）\n一个价值 vi（value）目标：选择若干物品装入背包，使得总重量不超过 W ，且总价值最大。\n\n如何理解资源分配的抽象模型？背包问题本质是资源受限下的最优策问题，其核心要素可映射到广泛场景\n\n背包容量 -&gt; 资源上线（预算、时间、空间）\n物品 -&gt; 待分配的任务、项目、货物等。\n价值与重量 -&gt; 收益与成本（利润与投入 、 重要性与耗时）。\n\n背包问题的基本形式0-1背包问题问题描述\n有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的总重量不超过背包容量，且总价值最大。\n解决思路\n\n暴力解法（理解问题） 最直观的方法就是尝试所有可能的组合，计算每种组合的总重量和价值，然后找出满足重量限制的最大价值组合。但这种方法时间复杂度是O(2^n^) ，当n较大时不可行\n\n动态规划解法 动态规划的核心思想是 “分而治之” 和 “记住求过的解来节省时间”。定义状态：f[i] [j] 表示考虑前 i 个物品，在背包容量为 j 时可以获得的最大价值\n\n\n状态转移方程：对于第 i 个物品，我们有两种选择：\n\n不选第 i 个物品：f[i] [j] &#x3D; f[i-1] [j]\n选第 i 个物品：f[i] [j] &#x3D; f[i-1] [j-w[i] ] + v[i]\n\n我们取这两种情况的最大值：f[i] [j] &#x3D; max{f[i-1][j], f[i-1] [j-w[i] ] +v[i] }\n初始化：f[0] [j] &#x3D; 0  （0个物品时价值为0）f[i] [0] &#x3D; 0 （背包容量为0时价值为0）\n具体例子：\n\n假设背包容量为6，每个物品只能选择取或者不取。\n物品：\n葡萄：w&#x3D;2，v&#x3D;3\n矿泉水：w&#x3D;3，v&#x3D;5\n西瓜：w&#x3D;4，v&#x3D;6\n\n\n\n\n\n\n物品\n容量w\n价值v\n\n\n\n葡萄\n2\n3\n\n\n矿泉水\n3\n5\n\n\n西瓜\n4\n6\n\n\n构建DP表：\n\n\n\n\n\ni 表示物品号 \nj 表示容量大小\n表内格子显示当考虑 物品 i 且背包容量为 j 时，背包内的最大价值\n\n\n\n\ni\\j\n0\n1\n2\n3\n4\n5\n6\n\n\n\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n0\n0\n3\n3\n3\n3\n3\n\n\n2\n0\n0\n3\n5\n5\n8\n8\n\n\n3\n0\n0\n3\n5\n6\n8\n9\n\n\n 解释：\n\n第一行：没有物品时，背包价值为0\n第二行：只有物品1（葡萄），只要容量 大于等于2就能装下，价值为3\n第三行：可以考虑物品 1（葡萄）和 物品 2 （矿泉水）\nj &#x3D; 3时：可以选择物品2 （矿泉水 价值5）或者 不选 （价值 3） 取max(5, 3) &#x3D;  5\nj &#x3D; 4时：可以选择物品2 （矿泉水 价值5）或者 不选 （价值 3） 取max(5, 3) &#x3D;  5\nj &#x3D; 5时：可以选择物品 2 + 物品 1 (矿泉水 价值5 + 葡萄 价值3 &#x3D; 8)或者不选 (矿泉水 价值5) 取max(8, 5 ) &#x3D; 8\nj &#x3D; 6时：可以悬着物品 2 + 物品 1 (矿泉水 价值5 + 葡萄 价值3 &#x3D; 8)或者不选 (矿泉水 价值5) 取max(8, 5) &#x3D;  8\n\n\n第四行：考虑所有物品\nj &#x3D; 4时：可以选择物品3 （西瓜 价值6）或者不选（价值 5 ），取max(6,5) &#x3D; 6\nj &#x3D; 6时：可以选择物品1 + 物品3(葡萄 价值3 + 西瓜 价值6 &#x3D; 9) 或者不选 （价值8） ，取max(9,8) &#x3D; 9\n\n\n\n注释：这里的不选是指，不选第 i 个物品，也就是当考虑第 i 个物品时，当不选 第 i 个物品那么, 对应的最优解是前 i-1 个物品的最优解，可以理解成与前一个解做比较，哪个更大留哪个\n0-1背包问题解法CC++PythonJAVARust//C代码部分#include &lt;stdio.h&gt;#define max(a, b) ((a) &gt; (b) ? (a) : (b))int main(void) &#123;    int N = 3, V = 6;    int w[] = &#123;0,2,3,4&#125;;    int v[] = &#123;0,3,5,6&#125;;    int f[N+ 1][V+ 1];    for(int i = 0; i &lt;= N; i++) &#123;        for(int j = 0; j &lt;= V; j++) &#123;            f[i][j] = 0;        &#125;    &#125;    for(int i = 1; i&lt;= N; i++)    &#123;        for(int j = 1; j &lt;= V; j++)        &#123;            if(j &lt; w[i])            &#123;                f[i][j] = f[i-1][j];            &#125;            else            &#123;                f[i][j] = max(f[i -1][j],f[i -1][j-w[i]] +v[i]);            &#125;        &#125;    &#125;    printf(&quot;%d&quot;,f[N][V]);    return 0;&#125;//C++代码部分#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    int N = 3 , V = 6;//物品数量为3 背包容量为6    int w[] = &#123;0,2,3,4&#125;;//物品占背包的容量    int v[] = &#123;0,3,5,6&#125;;//物品价值        //int f[N+ 1][V+ 1] = &#123;0&#125;;    int f[N+ 1][V+ 1];     for(int i = 0; i&lt;= N; i++) &#123;        for(int j = 0; j &lt;= V; j++) &#123;            f[i][j] = 0;        &#125;    &#125;        for(int i = 1; i&lt;= N; i++)    &#123;        for(int j = 1; j &lt;= V; j++)        &#123;            if(j &lt; w[i])            &#123;                f[i][j] = f[i-1][j];            &#125;            else            &#123;                f[i][j] = max(f[i- 1][j],f[i- 1][j-w[i]]+ v[i]);            &#125;        &#125;    &#125;        cout &lt;&lt;f[N][V] &lt;&lt;endl;    return 0;&#125;#Python代码部分def knapsack_01(N,V,w,v):    #初始化dp表    f = [[0] * (V + 1) for _ in range(N+ 1)]    for i in range(1, N+ 1):        for j in range(1, V+ 1):            if j&lt; w[i]:                f[i][j] = f[i- 1][j]            else:                f[i][j] = max(f[i- 1][j], f[i-1][j-w[i]]+ v[i])    return f[N][V]def main():    N = 3#物品数量    V = 6#背包容量    w = [0,2,3,4]#物品重量    v = [0,3,5,6]#物品价值        max_value = knapsack_01(N, V, w, v)    print(f&quot;背包能装下的最大价值为: &#123;max_value&#125;&quot;)if __name__ == &quot;__main__&quot;:    main()    //JAVApublic class Knapsack01 &#123;    public static int knapsack(int numItems, int capacity, int[] weights, int[] values) &#123;        // 创建动态规划表        int[][] dp = new int[numItems + 1][capacity + 1];        // 填充动态规划表        for (int i = 1; i &lt;= numItems; i++) &#123;            for (int j = 1; j &lt;= capacity; j++) &#123;                if (j &lt; weights[i]) &#123;                    dp[i][j] = dp[i - 1][j];                &#125; else &#123;                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i]);                &#125;            &#125;        &#125;        return dp[numItems][capacity];    &#125;    public static void main(String[] args) &#123;        // 测试数据        final int NUM_ITEMS = 3;        final int CAPACITY = 6;        int[] weights = &#123;0, 2, 3, 4&#125;;  // 索引0不使用        int[] values = &#123;0, 3, 5, 6&#125;;    // 索引0不使用        // 计算并输出结果        int maxValue = knapsack(NUM_ITEMS, CAPACITY, weights, values);        System.out.println(&quot;背包能装下的最大价值为: &quot; + maxValue);    &#125;&#125;//Rust代码部分fn knapsack_01(num_items: usize, capacity: usize, weights: &amp;[usize], values: &amp;[usize]) -&gt; usize &#123;    // 初始化动态规划表    let mut dp = vec![vec![0; capacity + 1]; num_items + 1];    //填充动态规划表    for i in 1..=num_items     &#123;        for j in 1..=capacity         &#123;            if j &lt; weights[i]             &#123;                dp[i][j] = dp[i - 1][j];            &#125;             else             &#123;                dp[i][j] = std::cmp::max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i]);            &#125;        &#125;    &#125;    dp[num_items][capacity]&#125;fn main() &#123;    // 物品数量    const NUM_ITEMS: usize = 3;    // 背包容量    const CAPACITY: usize = 6;    // 物品重量    let weights = vec![0, 2, 3, 4];    // 物品价值    let values = vec![0, 3, 5, 6];    let max_value = knapsack_01(NUM_ITEMS, CAPACITY, &amp;weights, &amp;values);    println!(&quot;背包能装下的最大价值为: &#123;&#125;&quot;, max_value);&#125;\n\n完全背包问题多重背包问题混合背包问题二维费用的背包问题分组背包问题背包问题求方案数求背包问题的方案有依赖的背包问题","categories":["algorithm"]},{"title":"嵌入式系统原理考试复习(1)","url":"/2025/06/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0-1/","content":"这里是非主观题的填空复习资料，选择请见复习(2)\n填空题部分一、填空题1. 【填空题】嵌入式系统应用源于20世纪70年代，其发展经历了________、________、________和________4个阶段。答案：无操作系统；简单操作系统；实时操作系统；面向Internet\n解析：考察知识：嵌入式系统概述(1)无操作系统：该阶段嵌入式系统以单片机为硬件核心，主要特点是——系统结构和功能单一、处理效率低、存储容量小、几乎没有用户接口。(2)简单操作系统：该阶段微控制器为硬件基础，主要特点是控制器种类繁多，通用性较小、有一定的兼容性、应用界面不友好。(3)实时操作系统：该阶段以实时操作系统为标志，主要特点是系统能运行与各种不同类型的微处理器上，兼容性好，具有高度的模块化，有大量应用程序接口。(4)该阶段是以Internet为标志，嵌入式设备联网称为嵌入式系统的必备属性。\n\n2.【填空题】嵌入式系统由________和________两部分组成。答案:嵌入式硬件；嵌入式软件\n考察知识：嵌入式系统概述略\n3.【填空题】嵌人式系统电路板在________基础上扩展了输人电路、通信接口、输出电路等,以实现信息获取、传输及设备控制。答案：最小系统\n考察知识：嵌入式系统概述略\n4.【填空题】嵌入式处理器可分为________、________、________和________四大类。答案：MCU;DSP;MPU;SOC\n考察知识：嵌入式系统概述嵌入式处理器可分为：微控制器（MCU）、数字信号处理器（DSP）、微处理器（MPU）、嵌入式片上系统（SOC）。记得要全大写\n5.嵌入式系统中常见的3种软件架构有________、和。答案：基于前后台的时间片轮询架构；顺序执行的前后台架构；多任务操作系统架构\n考察知识：嵌入式系统概述（1）基于前后台的时间片轮询架构：是基于前后台的时间片轮转法。（2）顺序执行的前后台：架构不含操作系统(也称裸机编程)，后台是一个无限大循环，前台是各种中断。特点是逻辑简单易于理解（3）多任务操作系统架构：架构需要运行嵌入式操作系统。\n6.【填空题】最重要的两个嵌入式系统软件编程思想是________和________。答案：分层思想；模块化思想\n考察知识：嵌入式系统概述(1) 分层思想：从下而上分成硬件抽象层、操作系统层、功能模块层、业务逻辑层 和 应用层，各层遵循，上层调用下层的函数接口，且不能跨层调用。(2) 模块化思想：模块与模块之间相互独立，模块功能只能增加，不能更改。\n7.【填空题】STM32 微控制器根据功能可分为________,________,________和________4个系列。答案：高性能；低功耗；无线；主流\n考察知识：STM32硬件及软件基础(1)高性能(2)低功耗(3)无线(4)主流\n8.【填空题】STM32L431RBT6 芯片的引脚数为________,Fash 大小为________。答案：64；128\n考察知识：STM32硬件及软件基础R:引脚数目64脚B：128k字节的闪存存储器\n9.【填空题】STM32 微控制器的引脚按功能可分为________、、、和。答案：电源；时钟；复位；输入；输出\n考察知识：STM32硬件及软件基础背的\n10.【填空题】STM32 微控制器的 NRST引脚输人________电平时，MCU将复位，当 NRST 从________电平变为________电平时，系然重新运行。答案：低；低；高\n考察知识：STM32硬件及软件基础NRST复位引脚：当NRST引脚出现一段时间低电平时，MCU将复位，重置所有的内部寄存器及RAM，当NRST从低电平变为高电平时，系统重新运行。\n11.【填空题】STM32微控制器的________引脚接外部电池，用于给RTC的一供电，允许RTC在统断电正常运行。答案：VBAT\n考察知识：STM32硬件及软件基础当主电源（VDD）断电时VBAT（电池正）会给实时时钟RTC，备份寄存器和备份SRAM供电，确保STM32 RTC模块实现低功耗持续运行。\n12.【填空题】典型STM32最小系统由________、、、________和________构成。答案：电源；时钟；复位；启动；下载；微控制器\n考察知识：STM32硬件及软件基础背就完了。\n13.【填空题】GPIO 通过读引脚电平状态实现开关信号的监测，当读到引脚状态为________时，表明引脚输入为高电平，此时可根据电路原理判断输入信号的开关状态。答案：1\n考察知识：STM32通用功能输入输出就这么定义的\n14.【填空题】无源开关信号指传感器输出本身不具备高低电平，正常状态时，NO 和 COM________，NC 和 COM________。答案：断路；连通\n考察知识：STM32通用功能输入输出略\n15.【填空题】由于有源信号输出具有极性，其输出高电平电压一般为 5V、12V 或 24V，超出了 MCU 引脚承受能力，因此不能直接接到 MCU 的引脚，可采用________进行隔离。答案：光电耦合器\n考察知识：STM32通用功能输入输出略\n16.【填空题】如果 IO 引脚配置为上拉输入，则该引脚默认输入状态为________电平。答案：高\n考察知识：STM32通用功能输入输出略\n17.【填空题】引脚配置为________输出时，双 MOS 工作，输出数据寄存器可控制 IO 输出高或低电平。答案：推挽\n考察知识：STM32通用功能输入输出略\n18.【填空题】STM32L4系列MCU最多有________个中断源，包括________个内核中断和________个可屏蔽中断。答案：83；16；67\n考察知识：STM32通用功能输入输出略\n19.【填空题】主程序被打断的地方称为________，即程序指针，指向________。答案：断点；下一条指令的地址\n考察知识：STM32通用功能输入输出略\n20.【填空题】中断服务程序在内存中的入口地址称为________。答案：中断向量地址\n\n21.【填空题】执行中断A时，发生了抢占优先级更高的中断B，则暂停中断A处理过程转去处理中断B，处理完中断B后再继续处理中断A，这个过程称为________。答案：中断嵌套\n\n22.【填空题】STM32外部中断是________引起的中断，由________和________控制。答案：引脚电平变化；NVIC；EXTI\n\n23.【填空题】EXTI内部电路主要由________、下降沿触发选择寄存器、上升沿触发选择寄存器、________、________等构成。答案：边沿检测电路；中断屏蔽寄存器；挂起请求寄存器\n\n24.【填空题】________提供了一个完全由硬件自动完成的程序执行通道，无须软件的参与，降低了CPU的负荷，提高了响应速度，是利用硬件提升MCU处理事件能力的有效方法。答案： EXTI\n\n25.【填空题】定时器应用中通常会面临四个基本问题是________、________、和。答案：周期；位数；计数值；中断处理\n\n26.【填空题】定时器的位数决定了定时器的计数最大值，十六位定时器计数最大值为________。答案：65535\n\n27.【填空题】STM32的滴答定时器（System Tick Timer, SysTick）是一个________位的定时器，具有自动重载和溢出中断功能。答案：24\n\n28.【填空题】看门狗定时器主要作用是当系统异常时________。答案：自动复位\n\n29.【填空题】外部计数模块通过外部输入引脚对________进行计数。答案：外部脉冲\n\n30.【填空题】时基单元是定时器的基本单元，由________、________和________三个寄存器构成。答案：预分频器；计数器；自动装载寄存器\n\n31.【填空题】PWM信号具有三个基本参数，即________、和。答案：周期；频率；占空比\n\n32.【填空题】利用STM32L431的定时器输出周期为1ms，占空比为66.6%的PWM，则应设置PSC &#x3D; ________，ARR &#x3D; ____，CCR &#x3D; ________。答案：80-1；1000；666\n\n33.【填空题】串行通信根据有无同步时钟可以分为________和________，根据传输方向可分为______、和。答案：同步串行通信；异步串行通信；单工；半双工；全双工\n\n34.【填空题】异步串行通信中一个字符帧至少包含________、和。答案：停止位；数据位；起始位\n\n35.【填空题】如果每个字符帧包含1个起始位、1个停止位、8个数据位，欲每秒传输11520个字符，则串口波特率应设置为________Baud。答案：115200\n\n36.【填空题】STM32进行异步串行双工通信时，至少需要________和________2个引脚。答案：RX；TX\n\n37.【填空题】一般STM32的USART1的发送引脚为________，接收引脚为________。答案： PA9；PA10\n\n38.【填空题】STM32的USART具有________、________和________3个完全独立的中断。答案：TX发送完成中断；TX发送数据寄存器空中断；RX接收完成中断\n\n39.【填空题】RTT操作系统架构从下往上依次为________、和。答案：内核层；组件服务层；软件包\n\n40.【填空题】内核是RT - Thread操作系统最基础的组成部分，包括________和________。答案： 内核库；实时内核\n\n41.【填空题】RT - Thread操作系统最小的调度单位是________。答案：线程\n\n42.【填空题】RT - Thread操作系统中时间的最小单位是________，默认设置为________。答案：时钟节拍；1-100ms\n\n43.【填空题】RT - Thread内存管理支持________和________。答案：静态；动态\n\n44.【填空题】RT - Thread内核对象管理系统的核心是________，包含了每类内核对象的类型、大小等信息，并给每类内核对象分配一个________。答案：容器；链表\n\n45.【填空题】每个线程都有________、________和________等重要属性。答案：线程控制块；线程栈；入口函数\n\n46.【填空题】RT - Thread的线程调度器是________，保证最高优先级的线程能够被优先运行。答案：抢占式\n\n47.【填空题】线程入口函数是线程实现预期功能的函数，有________和________两种模式。答案：无限循环；顺序执行\n\n48.【填空题】线程根据创建者可分为________和________。答案：系统线程；用户线程\n\n49.【填空题】空闲线程的优先级为_______，主要作用是________。答案：最低；回收被删除线程的资源\n\n50.【填空题】RT - Thread提供了________、________和________三种线程间同步方式。答案：信号量；互斥量；时间\n\n51.【填空题】线程可以获取和释放信号量，每成功获取一次信号量，信号值________，每成功释放一次信号量，信号值________。答案：+1\n\n52.【填空题】互斥量是一种特殊的二值信号量，只能由________线程获取和释放。答案：持有\n\n53.【填空题】互斥量采用________算法解决了优先级翻转问题。答案：优先级继承\n\n54.【填空题】每个事件集最多可以表示________个事件。答案：32\n\n55.【填空题】RT - Thread提供了________、________和________三种线程间通信方式。答案：邮箱；消息队列；信号\n\n56.【填空题】邮箱控制块是操作系统用于管理邮箱的一个数据结构，指向邮箱控制块的指针称为邮箱句柄，用________表示。答案：rt_mailbox_t\n\n57.【填空题】每个消息队列中包含着多个消息框，每个消息框可以存放________条消息，消息队列中的第一个和最后一个消息框分别称为________和________。答案：1；消息链表；消息链表层\n\n58.【填空题】消息队列允许发送紧急消息，其管理函数为________。答案：rt_mq_urgent\n\n59.【填空题】应用程序能够使用的信号为________和________。答案：SIGUSR1；SIGUSR2\n","categories":["school"]},{"title":"嵌入式系统原理考试复习(3)","url":"/2025/07/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0-3/","content":"这里是主观题的简答复习资料，程序设计题请见复习(4)\n三、简答题\n1. 【简答题】简述嵌入式系统的定义及特点。\n考察知识：嵌入式系统概述定义：以计算机技术为基础，以应用为中心，软件硬件可裁剪，功能可靠，成本，功耗严格要求的专用计算机系统特点：技术密集、以应用为中心、软硬件可裁剪、高可靠性和高实时性\n2. 【简答题】结合生活生产，列举嵌入式系统应用，并描述嵌入式系统发展趋势。\n考察知识：嵌入式系统概述应用：嵌入式系统应用于消费电子、工业控制、医疗设备、家庭智能管理系统、环境工程、机器人等（写上三个即可）发展趋势：（1）嵌入式发展趋势正朝着小型化、智能化、网络化、可视化发展。（2）云计算、可重构、虚拟化等技术被进一步应用到嵌入式系统。（3）嵌入式软件开发平台化、标准化，系统可升级、代码可复用。（4）低功耗、绿色环保和信息安全性。\n3. 【简答题】结合实际应用，设计嵌入式系统硬件架构。\n考察知识：嵌入式系统概述外围设备：通讯设备、控制设备、传感器嵌入式系统电路板：电路、接口、嵌入式处理器 和 电源\n4. 【简答题】ARM v7 架构分为哪几个系列？分别针对什么应用？\n考察知识：嵌入式系统概述分类：ARM v7架构分为 A系列（面向高性能应用），R系列（面向实时系统），M系列（面向低功耗低成本）。应用：A系列用于高档消费电子和无线产品、R系列用于实时性高的产品、M系列用于中低档控制应用。\n5. 【简答题】简述嵌入式系统软件架构。\n考察知识：嵌入式系统概述分类：（1）顺序执行的前后台架构：后台是一个按顺序执行的无限大循环，前台是各类中断和中断嵌套。（2）基于前后台的时间片轮询架构：选用一个定时器，每进行一次定时中断就对计数值自增一次，然后到达相应值时执行相应任务。（3）多任务操作系统架构：系统创建各个任务并启动任务，之后各个任务按照一定规则被系统调度运行。\n\n【简答题】结合所见所闻，提出一种实际应用，并分别采用 3 种软件架构实现该应用，并分析三者的优缺点。\n\n考察知识：嵌入式系统概述\n7. 【简答题】简述 GPIO 的概念。\n答案：GPIO（通用输入输出）是一种接口标准，允许微控制器或芯片与外部设备进行数字信号的输入输出通信。通过配置 GPIO 引脚为输入或输出模式，实现对设备的控制或数据采集。\n考察知识：\n\n8. 【简答题】举例描述 GPIO 的应用场景。\n答案：控制 LED 灯：将 GPIO 引脚设为输出模式，通过高低电平控制 LED 的亮灭，常用于设备状态指示。读取按键信号：将 GPIO 引脚设为输入模式，连接按钮开关，用于检测用户操作或外部信号输入。\n\n【简答题】根据 IO 内部电路结构描述 GPIO 作为输出和输入的工作原理。\n\n答案：GPIO 作为输出时，通过内部 MOS 管控制高低电平驱动外设；作为输入时，通过上拉 &#x2F; 下拉电阻和缓冲器读取外部信号状态。\n\n【简答题】IO 作为 GPIO 使用时共有几种工作模式，各种模式有何区别？\n\n答案：GPIO 有四种工作模式：输入上拉、输入下拉、推挽输出、开漏输出。输入模式区别在于是否有上拉或下拉电阻；输出模式区别在于推挽可直接驱动高低电平，开漏需外部上拉电阻才能输出高电平。\n\n【简答题】一个无源开关传感器，有常开（NO）和公共端（COM）两条连接线，如果 COM 接低电平，则 NO 应如何接？对应引脚应配置为何种模式？\n\n答案：如果 COM 端接低电平，NO 应接 GPIO 引脚，该引脚应配置为输入上拉模式。这样，当开关断开时，引脚读取高电平；当开关闭合时，引脚读取低电平。\n\n【简答题】简述 GPIO 应用步骤。\n\n答案：GPIO 应用步骤包括：配置引脚功能为输入或输出，设置上下拉电阻（若为输入），通过数据寄存器读取或写入电平状态，最后根据需要处理信号或控制外设。\n\n【简答题】简述中断的概念。\n\n答案：中断是外部设备或内部事件向处理器发出的请求信号，要求暂停当前任务，转去处理紧急事件，处理完成后恢复原任务执行。\n\n【简答题】举例描述 EXTI 的应用场景。\n\n答案：EXTI（外部中断）常用于检测按键按下、传感器触发或外部信号变化，例如通过按键中断实现设备的快速响应，提升系统实时性与交互效率。\n\n【简答题】根据 EXTI 内部电路结构描述它的工作原理。\n\n答案：EXTI 通过检测引脚电平或边沿变化触发中断请求，内部包含检测电路、使能寄存器和优先级控制器，将外部事件转化为 CPU 可响应的中断信号。\n\n【简答题】EXTI 有几种触发方式，各种触发方式有何区别？\n\n答案：EXTI 有三种触发方式：1. 上升沿触发：仅在信号从低变高时触发中断；2. 下降沿触发：仅在信号从高变低时触发中断；3. 双边沿触发：信号变化的上升沿和下降沿均可触发中断。区别在于检测的信号变化类型不同，适用于不同外部事件的检测需求。\n\n【简答题】一个无源开关传感器，有常开 (NO) 和公共端 (COM) 两条连接线，如果 COM 接低电平，则 NO 应如何接？对应引脚应配置为何种模式？\n\n答案：如果 COM 端接低电平，NO 应接 GPIO 引脚，并配置为输入上拉模式。这样，开关闭合时读取低电平，开关断开时读取高电平，实现状态检测。\n\n【简答题】简述 EXTI 应用步骤。\n\n答案：EXTI 应用步骤包括：配置 GPIO 为输入模式，设置 EXTI 线路与触发条件，使能中断并编写中断服务程序，最后在程序中处理中断事件。\n\n【简答题】简述定时器精确定时的应用步骤。\n\n答案：定时器精确定时步骤包括：配置定时器模式和预分频系数，设置自动重载值以确定定时周期，使能定时器及中断，最后在中断服务程序中处理定时事件。\n\n【简答题】简述定时器产生 PWM 的应用步骤。\n\n答案：定时器产生 PWM 步骤包括：配置定时器为 PWM 模式，设置周期和占空比，使能定时器通道，通过调整占空比控制输出脉宽，实现对设备的精确控制。\n\n【简答题】简述定时器产生 PWM 的工作原理。\n\n答案：定时器产生 PWM 的工作原理是通过设定定时周期和占空比，定时器按照设定值周期性地改变输出电平高低，从而生成具有特定频率和脉宽的方波信号。\n\n【简答题】画出异步串行通信发送数据 0x86 的数据帧格式，并分析发送过程。\n\n答案：无\n\n【简答题】分析 USART 用于异步串行通信的应用步骤。\n\n答案：USART 异步通信步骤：配置波特率、数据帧格式（起始位、数据位、校验位、停止位）、发送 &#x2F; 接收数据、处理完毕后释放资源。\n\n【简答题】分析 USART 异步串行通信时发送数据和接收数据的过程。\n\n答案：发送数据：配置 USART，加载数据到发送缓冲器，等待传输完成。接收数据：配置 USART，等待数据接收完毕，从接收缓冲器读取数据。过程中需处理好起始、停止位及可能的校验位。\n\n【简答题】结合程序分析 RT - Thread 的启动流程。\n\n答案：RT-Thread 启动流程：系统上电后进入main()函数，调用rtthread_startup()初始化内核，创建空闲线程与主线程，启动调度器，进入多线程运行状态。\n\n【简答题】搭建 RT - Thread 开发环境，分析程序存储结构。\n\n答案：RT-Thread 程序存储结构包含：代码段（.text）、只读数据段（.rodata）、已初始化数据段（.data）、未初始化数据段（.bss），以及堆栈空间，支持模块化和动态内存管理。\n\n【简答题】简要分析 RT - Thread 的线程状态转换过程。\n\n答案：RT-Thread 线程状态包括就绪、运行、阻塞和挂起。就绪线程被调度器选中后进入运行态；运行中线程等待资源则进入阻塞态；挂起态线程通过恢复进入就绪态，实现多任务调度与资源管理。\n\n【简答题】画图分析相同优先级的线程执行情况。\n\n答案：无\n\n【简答题】简述动态线程的应用步骤。\n\n答案：动态线程应用步骤包括：定义线程函数，使用rt_thread_create()创建线程，设置入口函数、堆栈大小和优先级，调用rt_thread_startup()启动线程，最后管理线程生命周期。\n\n【简答题】简要分析信号量的工作机制，并说明信号量的应用步骤。\n\n答案：信号量机制用于控制对共享资源的访问，通过 P（等待）和 V（释放）操作同步线程。应用步骤：创建信号量，P 操作申请资源，执行任务，V 操作释放资源，销毁信号量。\n\n【简答题】简要分析互斥量的工作机制，并说明互斥量的应用步骤。\n\n答案：互斥量机制确保一个时刻仅一个线程访问共享资源，防止竞争条件。应用步骤：创建互斥量，锁定互斥量以访问资源，完成操作后解锁互斥量，最后销毁互斥量释放资源。\n\n【简答题】简要分析事件集的工作机制，并说明事件集的应用步骤。\n\n答案：事件集机制允许多个线程等待多个事件的发生。应用步骤：创建事件集，线程等待特定事件，事件发生后发送通知，线程处理事件，最后根据需要清理事件集资源。\n\n【简答题】概括信号量和互斥量的不同点。\n\n答案：信号量用于控制对资源的访问数量，允许多个线程同时访问；互斥量确保唯一访问，防止数据竞争。信号量适用于资源池，互斥量用于保护共享数据或关键代码段。\n\n【简答题】简要分析邮箱的工作机制，并说明邮箱的应用步骤。\n\n答案：邮箱机制用于线程间异步传递数据，通过发送和接收消息实现通信。应用步骤：创建邮箱，发送方调用发送函数投递消息，接收方调用接收函数获取消息，处理完成后可释放或销毁邮箱资源。\n\n【简答题】简要分析消息队列的工作机制，并说明消息队列的应用步骤。\n\n答案：消息队列机制用于线程间高效传递较长数据，通过发送 &#x2F; 接收消息实现通信。应用步骤：创建队列，使用互斥量保护队列访问，发送方入队，接收方出队，完成后释放资源并销毁队列。\n\n【简答题】简要分析信号的工作机制，并说明事件集的应用步骤。\n\n答案：信号机制用于线程异步通知，通过发送信号中断线程执行。事件集应用步骤：创建事件集，线程等待特定事件，事件触发后唤醒线程处理，完成后清理事件集资源。\n\n【简答题】画出 IO 设备模型的继承和派生关系。\n\n答案：无\n\n【简答题】概况 PIN 设备的应用步骤。\n\n答案：PIN 设备应用步骤包括：初始化 PIN 设备，配置 PIN 为输入或输出模式，通过 API 读取或写入电平状态，使用完毕后清理资源，确保设备正常操作。\n\n【简答题】概括 UART 设备的应用步骤。\n\n答案：UART 设备应用步骤：初始化 UART 设置（波特率、数据位等），配置传输格式，发送或接收数据，使用完毕后关闭 UART 通道并释放资源。确保通信正确无误。\n\n【简答题】概括 TIM 设备的应用步骤。\n\n答案：TIM 设备应用步骤：初始化定时器，设置计数模式和预分频值，配置自动重载值，使能定时器及中断，编写中断服务程序处理定时事件，最后根据需要停止并关闭定时器。\n\n【简答题】概括 ADC 设备的应用步骤。\n\n答案：ADC 设备应用步骤：初始化 ADC 模块，配置采样时间和分辨率，启动转换过程，读取转换结果，根据需要处理数据，最后关闭 ADC 通道并释放资源。确保准确采集模拟信号。\n\n【简答题】简要概括 cJSON 的应用步骤，包括组包和解析。\n\n答案：cJSON 应用步骤：1. 组包：创建 JSON 对象，添加键值对，使用cJSON_Print()生成 JSON 字符串。2. 解析：使用cJSON_Parse()解析接收到的 JSON 字符串，通过键名获取对应值，最后释放内存。\n\n【简答题】简述 MQTT 的工作机制。\n\n答案：MQTT 通过发布 &#x2F; 订阅模式实现轻量级通信，客户端连接服务器（Broker）后可发布消息到主题或订阅主题接收消息，适用于低带宽、不稳定网络下的物联网设备通信。\n","categories":["school"]},{"title":"改变一个整数能得到的最大差值","url":"/2025/06/27/1432L/","content":"1432. 改变一个整数能得到的最大差值\n给你一个整数 num 。你可以对它进行以下步骤共计 两次：\n\n选择一个数字 x (0 &lt;= x &lt;= 9).\n选择另一个数字 y (0 &lt;= y &lt;= 9) 。数字 y 可以等于 x 。\n将 num 中所有出现 x 的数位都用 y 替换。\n\n令两次对 num 的操作得到的结果分别为 a 和 b 。\n请你返回 a 和 b 的 最大差值 。\n注意，a 和 b 必须不能 含有前导 0，并且 不为 0。\n示例 1：\n输入：num = 555输出：888解释：第一次选择 x = 5 且 y = 9 ，并把得到的新数字保存在 a 中。第二次选择 x = 5 且 y = 1 ，并把得到的新数字保存在 b 中。现在，我们有 a = 999 和 b = 111 ，最大差值为 888\n\n示例 2：\n输入：num = 9输出：8解释：第一次选择 x = 9 且 y = 9 ，并把得到的新数字保存在 a 中。第二次选择 x = 9 且 y = 1 ，并把得到的新数字保存在 b 中。现在，我们有 a = 9 和 b = 1 ，最大差值为 8\n\n示例 3：\n输入：num = 123456输出：820000\n\n示例 4：\n输入：num = 10000输出：80000\n\n示例 5：\n输入：num = 9288输出：8700\n\n提示：\n\n1 &lt;= num &lt;= 10^8\n\n","categories":["leetcode"]},{"title":"嵌入式系统原理考试复习(2)","url":"/2025/07/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0-2/","content":"二、选择题\n\n【单选题】一般用户创建的线程，优先级不可设置为（ ）。\n\nA. 0  \nB. 10  \nC. 20  \nD. 31  \n答案：D\n\n【单选题】调用函数（ ）不能使当前线程休眠100ms。\n\n  A. rt_thread_mdelay (100)  \nB. rt_thread_delay (100)  \nC. rt_thread_sleep (100)  \nD. rt_thread_sleep (100000)  \n答案：D\n\n【单选题】下列线程句柄定义正确的是（ ）。\n\n  A. rt_thread_t tid1;  \nB. rt_thread_t 1tid;  \nC. rt_thread_t  tid1;  \nD. rt_thread_t  1tid;  \n答案：A\n\n【单选题】STM32L系列微控制器的最高频率为（ ）MHz。\n\nA. 72B. 80C. 120D. 170  \n答案：C\n考察知识：STM32硬件及软件基础L系列代表低功耗，最高频率129MHz\n\n5. 【单选题】STM32L431RCT6不具有（ ）引脚。  \nA. PA15B. PB15C. PC15D. PD15  \n答案：D\n考察知识：STM32硬件及软件基础R代表管脚数为64PA0~15PB0~15PC0~15PD2故没有PD15\n\n6. 【单选题】STM32L4系列微控制的Flash最大为（ ）。  \nA. 64KBB. 128KBC. 256KBD. 512KB  \n答案：C\n考察知识：STM32硬件及软件基础背吧，没啥解释的\n\n【单选题】关键字（ ）用于声明只读的变量，其值不能被改变。\n\nA. constB. typedefC. volatileD. static  \n答案：A\n考察知识：STM32硬件及软件基础背吧，没啥解释的\n\n【单选题】定义int a [10] &#x3D; {0, 1, 2, 3, 4}; int * p &#x3D; a;则*(p+5)的值为（ ）。\n\nA. 0B. 1C. 2D. 3  \n答案：A\n考察知识：STM32硬件及软件基础p[5]~p[9]均未赋值所以都是0\n\n【单选题】当前信号值为4，则此刻最多有（ ）个线程可以成功获得信号量。\n\nA. 0  \nB. 2  \nC. 4  \nD. 6  \n答案：C\n\n【单选题】函数（ ）属于事件集的管理方式。\n\nA. rt_sem_take  \nB. rt_mutex_release  \nC. rt_event_send  \nD. rt_event_take  \n答案：C\n\n【单选题】异步串行通信的字符帧中（ ）不是必须的。\n\nA. 起始位  \nB. 停止位  \nC. 校验位  \nD. 数据位  \n答案：C\n\n【单选题】如果设置STM32的USART为异步模式，波特率为115200Baud，则每秒最多可以传输（ ）个字符帧。\n\nA. 10472  \nB. 115200  \nC. 12800  \nD. 13552  \n答案：B\n\n【单选题】STM32中断接收函数为（ ）。\n\nA. HAL_UART_Transmit_IT()  \nB. HAL_UART_Transmit()  \nC. HAL_UART_Receive_IT()  \nD. HAL_UART_Receive()  \n答案：C\n\n【单选题】STM32利用USART发送数据时，首先将数据存于（ ）寄存器。\n\nA. 发送移位  \nB. 发送数据  \nC. 接收移位  \nD. 接收数据  \n答案：B\n\n【单选题】下列属于内核层的为（ ）。\n\nA. 线程  \nB. OLED驱动  \nC. FinSH控制台  \nD. DFS虚拟文件系统  \n答案：A\n\n【单选题】（ ）不属于实时内核的文件。\n\nA. object.c  \nB. thread.c  \nC. kservice.c  \nD. device.c  \n答案：C\n\n【单选题】对于STM32，RT - Thread默认配置是（ ）个线程优先级。\n\nA. 0  \nB. 8  \nC. 32  \nD. 256  \n答案：C\n\n【单选题】下列不属于RT - Thread提供的线程间通信的为（ A）。\n\nA. 信号量  \nB. 邮箱  \nC. 消息队列  \nD. 信号  \n答案：A\n\n【单选题】在调度器启动之前进行初始化，应使用（ A）。\n\nA. INIT_BOARD_EXPORT  \nB. INIT_PREV_EXPORT  \nC. INIT_ENV_EXPORT  \nD. INIT_DEVICE_EXPORT  \n答案：A\n\n【单选题】下列哪个选项不属于 GPIO？（ ）\n\nA. 推挽输出  \nB. 开漏输出  \nC. 浮空输入  \nD. 模拟输入  \n答案：D\n\n【单选题】LED 阳极接引脚 PA0，LED 阴极经限流电阻接低电平，欲控制 LED 亮灭，则 PA0 可设置为何种模式？（A ）\n\nA. 推挽输出  \nB. 开漏输出  \nC. 上拉输入  \nD. 下拉输入  \n答案：A\n\n【单选题】执行下列哪条语句，可以使上题中的 LED 点亮？（ ）\n\nA. HAL_GPIO_WritePin (GPIOA, GPIO_Pin_0);  \nB. HAL_GPIO_ReadPin (GPIOA, GPIO_Pin_0);  \nC. HAL_GPIO_WritePin (GPIOA, GPIO_Pin_0, 1);  \nD. HAL_GPIO_WritePin (GPIOA, GPIO_Pin_0, 0);  \n答案：C\n\n【单选题】STM32 引脚 PB12 接按键 KEY1，则建议其用户标签设置为（ ）。\n\nA. K1  \nB. k1  \nC. KEY1  \nD. Key1  \n答案：C\n\n【单选题】连续执行 HAL_GPIO_TogglePin (GPIOA, GPIO_Pin_0) 三次，则 PA0 的状态为（ ）。\n\nA. 高电平  \nB. 低电平  \nC. 不确定  \nD. 与原状态相反  \n答案：D\n\n下列邮箱相关操作正确的是（ ）。\n\nA. rt_mb_t  \nB. rt_mailbox_t  \nC. rt_mb_receive  \nD. rt_mailbox_recv  \n答案：B\n\n【单选题】有4个中断A、B、C和D，抢占优先级和响应优先级分别为(2, 1)、(3, 2)、(1, 3)和(2, 2)，则4个中断同时发生时，中断执行顺序为（ ）。\n\nA. ABCD  \nB. CADB  \nC. CDAB  \nD. BDAC  \n答案：B\n\n【单选题】烟雾传感器输出接STM32的引脚PB8，无烟雾时输出低电平，检测到烟雾时输出高电平，则为了实现烟雾监测，PB8应如何配置?（ ）\n\nA. 外部中断模式，下拉输入，上升沿触发  \nB. 外部中断模式，上拉输入，上升沿触发  \nC. 外部中断模式，上拉输入，下降沿触发  \nD. 外部中断模式，下拉输入，双边沿触发  \n答案：A\n\n【单选题】若中断优先级分组设置为第2组，则最多可实现（ ）级中断嵌套。\n\nA. 2  \nB. 4  \nC. 6  \nD. 8  \n答案：B\n\n【单选题】STM32L4利用定时器产生1ms的溢出中断，如果设置PSC &#x3D; 79，则ARR &#x3D;（ ）。\n\nA. 10 - 1  \nB. 100 - 1  \nC. 1000 - 1  \nD. 10000 - 1  \n答案：C\n\n【单选题】PWM频率为10kHz，占空比为30%，高电平为3.3V，则PWM的平均电压为（ B）。\n\nA. 0.66V  \nB. 0.99V  \nC. 2.31V  \nD. 2.64V  \n答案：B\n\n【单选题】STM32输出PWM的周期和占空比由寄存器（ ）控制。\n\nA. PSC  \nB. PSC和ARR  \nC. PSC、ARR和CCR D. PSC、ARR、CCR和CNT  \n答案：C\n32. 【单选题】智能手机是嵌入式系统在（ ）领域的应用。 \nA. 消费电子B. 工业控制C. 医疗设备D. 环境工程 \n答案：A\n考察知识：嵌入式系统概述手机属于消耗性电子产品\n\n33. 【单选题】（ ）电路用于接收开关量传感器输入，实现开关信号监测。 \nA. 开关量输入B. 模拟量输入C. 开关量输出D. 模拟量输出 \n答案：A\n考察知识：嵌入式系统概述答案自在题干中\n\n【单选题】下列（ ）不是嵌入式系统软件的组成部分。\n\nA. 板级支持包B. 操作系统C. 应用程序D. 微控制器 \n答案：D\n考察知识：嵌入式系统概述微控制器属于硬件\n\n\n【单选题】（ ）片上外设资源比较丰富，内部集成了Flash、RAM、总线、定时器&#x2F;计数器、看门狗、I&#x2F;O、串行口等。\n\nA. MCUB. MPUC. FPGAD. DSP \n答案：A\n考察知识：嵌入式系统概述微控制器（MCU）芯片的外设丰富微处理器（MPU）只保留了和嵌入式应用紧密相关的功能硬件数字信号处理器（DSP）专门用于数字信号处理的嵌入式处理器现场可编程门阵列（FPGA）是一种先购买再设计的芯片\n\n【单选题】Cortex - M4核心是基于ARM（ ）架构的，用于中低档控制的产品。\n\nA. v6B. v7C. v8D. v9\n答案：B\n考察知识：嵌入式系统概述记就完了v7\n\n\n【单选题】RT-Thread中，线程的优先级数值越小表示(  )\n\nA. 优先级越低B. 优先级越高C. 与优先级无关D. 由用户自定义\n答案：B\n\n【单选题】STM32的定时器PWM输出模式是(  )\n\nA. 输出比较模式\nB. 输入捕获模式\nC. 编码器模式\nD. 脉冲计数模式\n答案：A\n\n【单选题】RT-Thread的线程间通信方式不包括(  )\n\nA. 消息队列\nB. 信号量\nC. 直接修改全局变量\nD. 邮箱\n答案：C\n\n【单选题】STM32的NVIC是什么功能模块(  )\n\nA. 外部中断控制器\nB. 时钟树配置器\nC. DMA控制器\nD. 电源管理模块\n答案：A\n\n【单选题】RT-Thread中，动态创建线程的函数是(  )\n\nA. rt_thread_init()\nB. rt_thread_create()\nC. rt_thread_startup()\nD. rt_thread_delete()\n答案：B\n\n【单选题】STM32的DMA控制器直接操作的对象是(  )\n\nA. CPU寄存器\nB. 外设和数据存储器\nC. 中断向量表\nD. 时钟树\n答案：B\n\n【单选题】RT-Thread的时钟节拍（tick）默认频率是(  )\n\nA. 1Hz\nB. 100Hz\nC. 1kHz\nD. 由用户配置\n答案：D\n\n【单选题】STM32的Flash编程操作中，擦除的最小单位通常是(  )\n\nA. 1字节\nB. 1页（如1KB）\nC. 整个芯片\nD. 4字节\n答案：B\n\n【单选题】RT-Thread中，以下哪个不是内存管理方式(  )\n\nA. 静态内存池\nB. 动态堆内存\nC. 直接操作物理地址\nD. 小内存管理算法\n答案：C\n\n【单选题】RT-Thread的设备驱动框架中，设备注册的函数是(  )\n\nA. rt_device_find()\nB. rt_device_register()\nC. rt_device_open()\nD. rt_device_init()\n答案：B\n\n【单选题】RT-Thread中，线程控制块（TCB）包含的主要信息是(  )\n\nA. 线程函数名\nB. 线程栈地址\nC. 线程优先级\nD. 线程状态、栈指针、优先级、入口函数等完整控制信息\n答案：D\n\n【单选题】RT-Thread的idle线程的主要作用是(  )\n\nA. 运行用户任务\nB. 处理高优先级中断\nC. 回收系统资源\nD. 执行低优先级后台任务\n答案：D\n","categories":["school"]},{"title":"嵌入式系统原理考试复习(4)","url":"/2025/07/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0-4/","content":"这里是主观题的程序设计题复习资料\n程序设计题五、程序设计题\n1.【程序设计题】请基于已有代码架构完成STM32CubeIDE风格的代码补写，实现LED1再快速闪烁三次后以1s一次间隔闪烁的功能\nint main(void)&#123;  /* USER CODE BEGIN 1 */  int i = 0;  /* USER CODE END 1 */  /* MCU Configuration--------------------------------------------------------*/  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */  HAL_Init();  /* USER CODE BEGIN Init */  /* USER CODE END Init */  /* Configure the system clock */  SystemClock_Config();  /* USER CODE BEGIN SysInit */  /* USER CODE END SysInit */  /* Initialize all configured peripherals */  MX_GPIO_Init();  /* USER CODE BEGIN 2 */  for(i=0;i&lt;6;i++)  &#123;    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);    HAL_Delay(500);/  &#125;  /* USER CODE END 2 */  /* Infinite loop */  /* USER CODE BEGIN WHILE */  while (1)  &#123;    /* USER CODE END WHILE *///在这里写下你的代码    /* USER CODE BEGIN 3 */  &#125;  /* USER CODE END 3 */&#125;\n\n\n答案：  HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin); \t\t HAL_Delay(1000);\n2.【程序设计题】请基于已有代码架构完成STM32CubeIDE风格的代码补写，实现按下按键K1松开后，LED2熄灭，再按下按键K2松开后，LED2亮起（默认LED2初始状态为亮）\n//实例While(1)&#123;HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);HAL_Delay(1000);if(HAL_GPIO_ReadPin(K1_GPIO_Port,K1_Pin))&#123;while(HAL_GPIO_ReadPin(K1_GPIO_Port,K1_Pin));HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);&#125;&#125;//代码实现While(1)&#123;HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);HAL_Delay(1000);//在这里写下你的代码&#125;\n\n答案：if(HAL_GPIO_ReadPin(K1_GPIO_Port,K1_Pin)){while(HAL_GPIO_ReadPin(K1_GPIO_Port,K1_Pin));HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);}if(HAL_GPIO_ReadPin(K2_GPIO_Port,K2_Pin)){while(HAL_GPIO_ReadPin(K2_GPIO_Port,K2_Pin));HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);}\n3.【程序设计题】请基于已有代码架构完成STM32CubeIDE风格的代码补写，实现按下按键K1的瞬间，LED1状态翻转，再按下按键K2的瞬间，LED2状态翻转。\n//实例While(1)&#123;if(HAL_GPIO_ReadPin(K2_GPIO_Port,K2_Pin))&#123;while(HAL_GPIO_ReadPin(K2_GPIO_Port,K2_Pin));HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);&#125;if(GPIO_Pin == K1_Pin)&#123;HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);&#125;&#125;//代码实现While(1)&#123;//在下面写下你的代码&#125;\n\n答案：if(GPIO_Pin &#x3D;&#x3D; K1_Pin){HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);}if(GPIO_Pin &#x3D;&#x3D; K2_Pin){HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);}4. 【程序设计题】当我们在使用邮箱进行线程间通信时，一般有四个步骤，定义邮箱句柄，主线程创建邮箱，发送邮箱，以及接收邮箱，根据下面实例完成带代码补写\n//实例：void ti1_entry(void* paramenter)&#123;int a = 100;char b = “hello RTT!”;rt_mb_send(dmb,(rt_ubase_t) a));rt_mb_send(dmb,(rt_ubase_t) b);&#125;void tid2_entry(void* paramenter)&#123;int a;char b[15];rt_mb_recv(dmb,(rt_ubase_t*)&amp;a.RT_WAITING_FOREVER);rt_mb_recv(dmb,(rt_ubase_t*)b.RT_WAITING_FOREVER);&#125;int main（void）&#123;rt_thread_t tid1,tid2;dmb = rt_mb_create(“dmb”,10,RT_IPC_FLAG_FIFO);//在这里写下你的代码rt_thread_startup(tid1);rt_thread_startup(tid2);&#125;\n答案：tid1 &#x3D; rt_thread_create(“tid1”,tid1_entry,RT_NULL,1024,10,10);tid2 &#x3D; rt_thread_create(“tid2”,tid2_entry,RT_NULL,1024,10,10);\n5.【程序设计题】当我们在使用邮箱进行线程间通信时，一般有四个步骤，定义邮箱句柄，主线程创建邮箱，发送邮箱，以及接收邮箱，根据下面实例完成带代码补写\n//实例：void ti1_entry(void* paramenter)&#123;int a = 100;char b = “hello RTT!”;//在这里写下你的代码&#125;void tid2_entry(void* paramenter)&#123;int a;char b[15];rt_mb_recv(dmb,(rt_ubase_t*)&amp;a.RT_WAITING_FOREVER);rt_mb_recv(dmb,(rt_ubase_t*)b.RT_WAITING_FOREVER);&#125;int main（void）&#123;rt_thread_t tid1,tid2;dmb = rt_mb_create(“dmb”,10,RT_IPC_FLAG_FIFO);tid1 = rt_thread_create(“tid1”,tid1_entry,RT_NULL,1024,10,10);tid2 = rt_thread_create(“tid2”,tid2_entry,RT_NULL,1024,10,10);rt_thread_startup(tid1);rt_thread_startup(tid2);&#125;\n答案：rt_mb_send(dmb,(rt_ubase_t) a);rt_mb_send(dmb,(rt_ubase_t) b);\n6.【程序设计题】当我们在使用邮箱进行线程间通信时，一般有四个步骤，定义邮箱句柄，主线程创建邮箱，发送邮箱，以及接收邮箱，根据下面实例完成带代码补写\n//实例：void ti1_entry(void* paramenter)&#123;int a = 100;char b = “hello RTT!”;rt_mb_send（dmb,(rt_ubase_t) a));rt_mb_send(dmb,(rt_ubase_t) b);&#125;void tid2_entry(void* paramenter)&#123;int a;char b[15];//在这里写下你的代码&#125;int main（void）&#123;rt_thread_t tid1,tid2;dmb = rt_mb_create(“dmb”,10,RT_IPC_FLAG_FIFO);tid1 = rt_thread_create(“tid1”,tid1_entry,RT_NULL,1024,10,10);tid2 = rt_thread_create(“tid2”,tid2_entry,RT_NULL,1024,10,10);rt_thread_startup(tid1);rt_thread_startup(tid2);&#125;\n答案：rt_mb_recv(dmb,(rt_ubase_t*)&amp;a.RT_WAITING_FOREVER);rt_mb_recv(dmb,(rt_ubase_t*)b.RT_WAITING_FOREVER);\n7.【程序设计题】当我们在使用邮箱进行线程间通信时，一般有四个步骤，定义邮箱句柄，主线程创建邮箱，发送邮箱，以及接收邮箱，根据下面实例完成带代码补写\n//实例：void ti1_entry(void* paramenter)&#123;int a = 100;char b = “hello RTT!”;rt_mb_sendc(dmb,(rt_ubase_t) a));rt_mb_send(dmb,(rt_ubase_t) b);&#125;void tid2_entry(void* paramenter)&#123;int a;char b[15];rt_mb_recv(dmb,(rt_ubase_t*)&amp;a.RT_WAITING_FOREVER);rt_mb_recv(dmb,(rt_ubase_t*)b.RT_WAITING_FOREVER);&#125;int main（void）&#123;rt_thread_t tid1,tid2;dmb = rt_mb_create(“dmb”,10,RT_IPC_FLAG_FIFO);tid1 = rt_thread_create(“tid1”,tid1_entry,RT_NULL,1024,10,10);tid2 = rt_thread_create(“tid2”,tid2_entry,RT_NULL,1024,10,10);//在这里写下你的代码&#125;\n答案：rt_thread_startup(tid1);rt_thread_startup(tid2);\n补充复习资料1.创建2个线程，在线程切换时打印线程信息。（直接写线程函数和主函数）答案：\nvoid tid1_entry(void* parameter)&#123;    rt_kprintf(&quot;1&quot;);    rt_thread_mdelay(100);&#125; void tid2_entry(void *parameter) &#123;     rt_kprintf(&quot;2&quot;);     rt_thread_mdelay(100); &#125;int main(void)&#123;    rt_thread_t tid1,tid2;    tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid2_entry,RT_NULL,1024,10,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);        return RT_EOK;&#125;\n2.创建3个线程，其中2个线程优先级相同，另1个线程优先级较高，编程分析3个线程的运行情况。（直接写线程函数和主函数）\nvoid tid1_entry(void *parameter)&#123;    rt_kprintf(&quot;1&quot;);    rt_thread_mdelay(100);&#125;void tid2_entry(void *parameter)&#123;    rt_kprintf(&quot;2&quot;);    rt_thread_mdelay(100);&#125;void tid3_entry(void *parameter)&#123;    rt_kprintf(&quot;3&quot;);    rt_thread_mdelay(100);&#125;int main(void)&#123;\trt_thread_t tid1,tid2,tid3;        tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid2_entry,RT_NULL,1024,10,10);        tid3 = rt_thread_create(&quot;tid3&quot;,tid3_entry,RT_NULL,1024,5,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);    rt_threat_startup(tid3);&#125;\n3.创建2个线程，2个线程共用1个线程入口函数，通过参数控制LED1和LED2分别间隔1s和0.5s闪烁。（直接写线程函数和主函数）#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;#include &lt;board.h&gt;\n#define LED1 GET_PIN (A,0)#define LED2 GET_PIN (A,1)\nrt_pin_mode(LED1_PIN, PIN_MODE_OUTPUT);rt_pin_mode(LED2_PIN, PIN_MODE_OUTPUT);rt_pin_write(LED1_PIN, PIN_LOW);rt_pin_write(LED2_PIN, PIN_LOW);\nvoid led_entry(void * parameter)&#123;    rt_uint32_t led_pin = (rt_uint32_t)parameter;    rt_uint32_t delay_time = (led_pin == LED1)?1000:500;        while(1)    &#123;        rt_pin_write(led_pin, ! rt_pin_read(led_pin));        rt_thread_mdelay(delay_time);    &#125;&#125;int main(void)&#123;    rt_thread_t led1,led2;        led1 = rt_thread_create(&quot;led1&quot;,led_entry,(void*)LED1,1024,10,10);    led2 = rt_thread_create(&quot;led2&quot;,led_entry,(void*)LED2,1024,10,10);        rt_thread_startup(led1);    rt-thread_startip(led2);        return RT_EOK;&#125;\n4.创建3个线程，分别用于控制LED1、LED2和LED3.（1）LED1间隔0.5s闪烁；（2）LED2在LED1闪烁3次后，开始间隔1s闪烁；（3）LED3在LED1和LED2都闪烁5次后，开始间隔2s闪烁。（直接写线程函数和主函数）\n#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;#include &lt;board.h&gt;\n#define LED1 GET_PIN (A,0)#define LED2 GET_PIN (A,1)#define LED3 GET_PIN (A,4)\n#define E_LED1 ( 1 &lt;&lt; 3 )#define E_LED2 ( 1 &lt;&lt; 5 )\nrt_sem_t sled12;rt_event_t eled123;\nvoid led1_entry(void *parameter)&#123;    int count =0;        while(1)    &#123;        rt_pin_write(LED1, !rt_pin_read(LED1));        rt_thread_mdealy(500);//0.5s                if(++count == 6 &amp;&amp; sled12 != RT_NULL)        &#123;            rt_sem_release(sled12);        &#125;        if(++count == 10 &amp;&amp; eled123 != RT_NULL)        &#123;            rt_event_send(eled123,E1);        &#125;    &#125;&#125;void led2_entry(void *parameter)&#123;    int count = 0;    rt_sem_take(sled12,RT_WAITING_FOREVER);    rt_sem_delete(sled12);            while(1)    &#123;        rt_pin_write(LED2,!rt_pin_read(read));        rt_thread_mdelay(1000);                if(count++ == 10)        &#123;            rt_event_send(eled123,E2);        &#125;    &#125;&#125;void led3_entry (void * parameter)&#123;    rt_uint32_t e;    rt_event_recv(eled123,E1| E2,RT_EVENT_FLAG_AND |RT_EVENT_FLAG_CLEAR,RT_WAITING_FOREVER,&amp;e);    rt_event_delete(eled123);    while(1)    &#123;        rt_pin_write(LED3,!rt_pin_read(LED3));        rt_thread_mdelay(2000);    &#125;&#125;int main(void)&#123;    rt_thread_t led1,led2,led3;        sled12 = rt_sem_create(&quot;sled12&quot;,0,RT_IPC_FLAG_FIFO);    sled123 = rt_event_create(&quot;sled123&quot;,RT_IPC_FLAG_FIFO);        led1 = rt_thread_create(&quot;led1&quot;,led1_entry,RT_NULL,1024,10,10);    led2 = rt_thread_create(&quot;led2&quot;,led1_entry,RT_NULL,1024,11,10);    led3 = rt_thread_create(&quot;led3&quot;,led1_entry,RT_NULL,1024,12,10);        rt_thread_startup(led1);    rt_thread_startup(led2);    rt_thread_startup(led3);        return RT_EOK;&#125;\n5.创建线程t_data_get1和t_data_get2用于获取温湿度信息，温湿度信息可以用随机数模拟；创建线程t_data_print用于接收并打印温湿度信息；创建消息队列q_get_print,线程t_data_get1和线程t_data_get2发送消息至消息队列，线程t_data_print从消息队列中获取消息（直接写线程函数和主函数）\n#include &lt;rtthread.h&gt;#include &lt;stdlib.h&gt;\nstruct data_ht{int  id;int  humi;int  temp;};\nrt_mq_t  q_get_print;\nvoid t_data_get1_entry(void* parameter)&#123;    struct data_ht datra;    while(1)    &#123;        data.id = 1;        data.humi = rand()%100;        data.temp = rand()%100;                rt_mq_send(q_get_print,&amp;data,sizeof(data));        rt_thread_mdelay(1000);    &#125;  &#125;void t_data_get2_entry(void* parameter)&#123;    struct data_ht data;    while(1)    &#123;        data.id = 2;        data.humi = rand()%100;        data.temp = rand()%100;                rt_mq_send(q_get_print,&amp;data,sizeof(data));        rt_thread_mdelay(1000);    &#125;    &#125;void t_data_print_entry(void* parameter)&#123;    struct data_ht data;    while(1)    &#123;        rt_mq_recv(q_get_print,&amp;data,sizeof(data),RT_WAITING_FOREVER);        rt_kprint(&quot;id:%d,humi:%d,temp:%d\\n&quot;,data.id,data.humi,data.temp);    &#125;&#125;int main(void)&#123;    rt_thread_t t_data_get1,t_data_get2,t_data_print;    rt_mq_t q_get_print;        t_data_get1 = rt_thread_create(&quot;t_data_get1&quot;,t_data_get1_entry,RT_NULL,1024,10,10,10);    t_data_get2 = rt_thread_create(&quot;t_data_get2&quot;,t_data_get2_entry,RT_NULL,1024,10,10,10);    t_data_print = rt_thread_create(&quot;t_data_print&quot;,t_data_print_entry,RT_NULL,1024,10,10,10);        q_get_print = rt_mq_create(&quot;q_get_print&quot;,sizeof(data_ht),10,RT_IPC_FLAG_FIFO);        rt_thread_startup(t_data_get1);    rt_thread_startup(t_data_get2);    rt_thread_startup(t_data_print);        retuen RT_EOK;&#125;\n\n6.创建3个线程，分别用于控制LED1、LED2和LED3.（1）LED1间隔1s闪烁；（2）LED2在LED1闪烁3次后，开始间隔0.5s闪烁；（3）LED3在LED1和LED2都闪烁3次后，开始间隔1s闪烁。（直接写线程函数和主函数）\n#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;#include &lt;board.h&gt;\n#define LED1 GET_PIN (A,0)#define LED2 GET_PIN (A,1)#define LED3 GET_PIN (A,4)\n#define E_LED1 ( 1 &lt;&lt; 3 )#define E_LED2 ( 1 &lt;&lt; 5 )\nrt_sem_t sled12;Rt_event_t eled123;\nvoid tid1_entry(void* parameter)&#123;    int count = 0;    while(1)    &#123;        rt_pin_write(LED1,!rt_pin_read(LED1));        rt_thread_mdelay(1000);                if(++count == 6 &amp;&amp; slem12 != RT_NULL)        &#123;            rt_sem_release(sled12);            rt_event_send(eled123,E_LED1);        &#125;    &#125;&#125;void tid2_entry(void* parameter)&#123;    int count = 0;    rt_sem_take(sled12,RT_WAITING_FOREVER);    rt_sem_delete(sled12);    while(1)    &#123;        rt_pin_write(LED2,!rt_pin_read(LED2));        rt_thread_mdelay(500);                if(count == 6 &amp;&amp; eled123 != RT_NULL)        &#123;            rt_event_send(eled123,E_LED2);        &#125;    &#125;&#125;void tid3_entry(void* parameter)&#123;    rt_uint32_t e;    rt_event_recv(eled123,E_LED1|E_LED2,RT_EVENT_FLAG_AND|RT_EVENT_FLAG_CLEAR,RT_WAITING_FOREVER,&amp;e);    rt_event_delete(eled123);    while(1)    &#123;        rt_pin_write(LED3,!rt_pin_read(LED3));        rt_thread_mdelay(1000);    &#125;&#125;int main(void)&#123;    rt_thread_t tid1,tid2,tid3;        sled12 = rt_sem_create(sled12,0,RT_IPC_FLAG_FIFO);    eled123 = rt_event_create(eled123,RT_IPC_FLAG_FIFO);    tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid2_entry,RT_NULL,1024,11,10);    tid3 = rt_thread_create(&quot;tid3&quot;,tid3-entry,RT_NULL,1024,12,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);    rt_thread_startup(tid3);    \treturn RT_EOK;&#125;\n7.创建3个线程，分别用于控制LED1、LED2和LED3.（1）LED1间隔1s闪烁；（2）LED2在LED1闪烁5次后，开始间隔1s闪烁；（3）LED3在LED1和LED2都闪烁3次后，开始间隔1s闪烁。（直接写线程函数和主函数）#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;#include &lt;board.h&gt;\n#define LED1 GET_PIN (A,0)#define LED2 GET_PIN (A,1)#define LED3 GET_PIN (A,4)\n#define E_LED1 ( 1 &lt;&lt; 3 )#define E_LED2 ( 1 &lt;&lt; 5 )\nrt_sem_t sled12;Rt_event_t eled123;\nvoid tid1_entry(void* parameter)&#123;    int count = 0;    while(1)    &#123;        rt_pin_write(LED1,!rt_pin_read(LED1));        rt_thread_mdelay(1000);        if(++count == 6 &amp;&amp; eled123 != RT_NULL)        &#123;            rt_event_send(eled123,E_LED1);        &#125;        if(++count ==10 &amp;&amp; sled12 != RT_NULL)        &#123;            rt_sem_release(sled12);        &#125;    &#125;&#125;void tid2_entry(void* parameter)&#123;    int count ==0;    rt_sem_take(sled12,RT_WAITING_FOREVER);    rt_sem_delete(sled12);    while(1)    &#123;        rt_pin_write(LED2,!rt_pin_read(LED2));        rt_thread_mdelay(1000);                if(++count == 6 &amp;&amp; eled123 != RT_NULL )        &#123;            rt_event_send(eled123,E_LED2);        &#125;    &#125;&#125;void tid3_entry(void* parameter)&#123;    rt_uint32_t e;    rt_event_recv(eled123,LED1_E|LED2_E,RT_FLGA_AND|RT_FLGA_CLEAR,RT_WAITING_FOREVER,&amp;e);    rt_event_delete(eled123);    while(1)    &#123;        rt_pin_write(LED3,rt_pin_read(LED3));        rt_thread_mdelay(1000);        &#125;&#125;int mian(void)&#123;\trt_thread_t tid1,tid2,tid3;        sled12 = rt_sem_create(sled12,0,RT_IPC_FLAG_FIFO);    eled123 = rt_event_create(eled123,RT_IPC_FLAG_FIFO);    tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid2_entry,RT_NULL,1024,11,10);    tid3 = rt_thread_create(&quot;tid3&quot;,tid3_entry,RT_NULL,1024,12,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);    rt_thread_startup(tid3);    \treturn RT_EOK;&#125;\n8.创建2个线程，2个线程共用1个线程入口函数，通过参数控制LED1和LED2分别间隔1s和2s闪烁。（直接写线程函数和主函数）#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;#include &lt;board.h&gt;\n#define LED1 GET_PIN (A,0)#define LED2 GET_PIN (A,1)\nvoid tid_entry(void* parameter)&#123;    rt_uint32_t led_pin = (rt_uint32_t) parameter;    rt_uint32_t time_delay = (led_pin==LED1)?1000:2000;        while(1)    &#123;        rt_pin_write(led_pin,!rt_pin_read(led_pin));        rt_thread_mdelay(time_delay);    &#125;&#125;int main(void)&#123;    rt_thread_t tid1,tid2;        tid1 = rt_threat_create(&quot;tid1&quot;,tid_entry,(void*)LED1,1024,10,10);    tid2 = rt_threat_create(&quot;tid2&quot;,tid_entry,(void*)LED2,1024,10,10);        rt_threat_startup(tid1);    rt_threat_startup(tid2);&#125;\n9.创建2个线程，2个线程共用1个线程入口函数，通过参数控制LED1和LED2分别间隔1s和0.5s闪烁。（直接写线程函数和主函数）#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;#include &lt;board.h&gt;\n#define LED1 GET_PIN (A,0)#define LED2 GET_PIN (A,1)\nvoid tid_entry(void* parameter)&#123;    rt_uint32_t led_pin = (rt_uint32_t)parameter;    rt_uint32_t time_delay = (led_pin== LED1)?1000:500;    while(1)    &#123;        rt_pin_write(led_pin,!rt_pin_read(led_pin));        rt_thread_mdelay(time_delay);    &#125;&#125;int main(void)&#123;    rt_thread_t tid1,tid2;        tid1 = rt_thread_create(&quot;tid1&quot;,tid_entry,(void*)LED1,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid_entry,(void*)LED2,1024,10,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);&#125;\n\n10.编写信号量应用示例程序。答案：\nvoid tid1_entry(void* parameter)&#123;    rt_sem_release(dsem);&#125;void tid2_entry(void* parameter)&#123;    rt_sem_take(dsem);&#125;int main(void)&#123;    rt_sem_t dsem;    rt_thread_t tid1,tid2;        dsem = rt_sem_create(&quot;dsem&quot;,0,RT_FLAG_FIFO);    tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid2_entry,RT_NULL,1024,10,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);    return RT_EOK;&#125;\n11.【应用设计题】编写互斥量应用示例程序。答案：\nvoid tid1_entry(void* parameter)&#123;    rt_mutex_take(dmutex,RT_WAITING_FOREVER);    rt_mutex_release(dmutex);    rt_thread(dmutex);    rt_thread_mdelay(100);&#125;void tid2_entry(void* parameter)&#123;    rt_mutex_take(dmutex,RT_WAITING_FOREVER);    rt_mutex_release(dmutex);    rt_thread(dmutex);    rt_thread_mdelay(100);&#125;int main(void)&#123;\trt_mutex_t dmutex;    rt_thread_t tid1,tid2;        dmutex = rt_mutex_create(&quot;dmutex&quot;,RT_IPC_FLAG_FIFO);    tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid1 = rt_thread_create(&quot;tid2&quot;,tid2_entry,RT_NULL,1024,10,10);        rt_thread_start(tid1);    rt_thread_start(tid2);    return RT_EOK;&#125;\n12.编写事件集应用示例程序。\n#define E2  ( 1 &lt;&lt; 2  )#define E29 ( 1 &lt;&lt; 29 )\nrt_event_t e_t12;rt_thread_t tid1,tid2;\nvoid tid1_entry(void* parameter)&#123;    rt_event_send(e_t12,E2);    rt_event_send(e_t12,E29);&#125;void tid2_entry(void* parameter)&#123;    rt_uint32_t e;    rt_event_recev(e_12,E2|E29,RT_EVENT_FLAG_AND | RT_EVENT_FLAG_CLEAR,RT_WAITING_FOREVER.&amp;e);&#125;int main(void)&#123;    rt_event_t e_t12;    rt_thread_t tid1,tid2;        e_t12 = rt_event_create(&quot;e_t12&quot;,RT_IPC_FLAG_FIFO);    tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid1_entry,RT_NULL,1024,10,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);    return RT_EOK;&#125;\n13.编写邮箱应用示例程序。答案：\nvoid tid1_entry(void* parameter)&#123;    int a = 400;    char b = [Hello RTT.];    rt_mb_send(dmb,(rt_ubase)a);    rt_mb_send(dmb,(rt_ubase)b);    rt_thread_mdelay(100);&#125;voud tid2_entry(vois *parameter)&#123;    int a;    char b[15];    rt_mb_recv(dmb,(rt_ubase*) &amp;a,RT_WAITING_FOREVER);    rt_mb_revc(dmb,(rt_ubase*) b,RT_WAITING_FOREVER);&#125;int main(void)&#123;    rt_mailbox_t dmb;    rt_thread_t tid1,tid2;        dmb = rt_mailbox_create(dmb,10,RT_IPC_FLAG_FIFO);    tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid2_entry,RT_NULL,1024,10,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);        return RT_EOK;&#125;\n14.编写消息队列应用示例程序。答案：\nvoid tid1_entry(void* parameter)&#123;    int a =100;    char b[] = &quot;hello RTT.&quot;;        rt_mq_send(dmq,&amp;a,4);    rt_mq_send(dmq,&amp;b,sizeof(b));&#125;void tid1_entry(void* parameter)&#123;    int a;    char b[15];        rt_mq_recv(dmq,&amp;a,4,RT_WAITING_FOREVER);    rt_mq_recv(dmq,&amp;b,sizeof(b),RT_WAITING_FOREVER);&#125;int main(void)&#123;    rt_mq_t dmq;    rt_thread_t tid1,tid2;        dmq = rt_mq_create(dmq,10,RT_IPC_FLAG_FIFO);    tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid2_entry,RT_NULL,1024,10,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);        return RT_EOK;&#125;\n15.编写信号应用示例程序。答案：\nvoid tid1_signal_handler(int sig)&#123;    rt_kprintf(&quot;%d\\n&quot;,sig);&#125;void tid1_entry(void* parameter)&#123;    rt_signal_install(SIGUSR1,tid1_signal_handler);        rt_signal_unmask(SIGUSR1);&#125;void tid1_entry(void* parameter)&#123;\trt_thread_kill(SIGUSR1);&#125;int main(void)&#123;        rt_thread_t tid1,tid2;        tid1 = rt_thread_create(&quot;tid1&quot;,tid1_entry,RT_NULL,1024,10,10);    tid2 = rt_thread_create(&quot;tid2&quot;,tid2_entry,RT_NULL,1024,10,10);        rt_thread_startup(tid1);    rt_thread_startup(tid2);    return RT_EOK;&#125;\n","categories":["school"]}]